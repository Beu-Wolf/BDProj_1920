\documentclass[12pt]{report}
\usepackage[textwidth=17cm, margin=2cm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{enumitem}
\usepackage{multicol}
\usepackage{amsmath}
\usepackage{listings}

\begin{document}

    \begin{titlepage}
        \begin{center}

            \vspace*{\fill}
            \Huge
            \textbf{Projeto de Bases de Dados - Parte 3}

            \vspace*{\fill}

            \Large
            \textbf{Grupo 27} \\
            89427 - Daniel Seara - 33,3\% - 14 horas \\
            89399 - Afonso Gonçalves - 33,3\% - 14 horas \\
            89496 - Marcelo Santos - 33,3\% - 14 horas \\

            \bigskip
            \textbf{Turno:} 4ª Feira 9h30 - Lab 8\\ \textbf{Professor:} Duarte Galvão

        \end{center}
    \end{titlepage}

    \Large
    \textbf{Criação e Preenchimento da base de Dados:}\\

    \normalsize
    \vspace{2mm}
    Após a instalação e configuração do PostgreSQL no computador host, criou-se uma Base de Dados chamada \textit{translateRight} com o seguinte comando na shell:
    \begin{verbatim}
        $ createdb translateRight
    \end{verbatim}

    Para popular a base de dados usaram-se dois ficheiros .sql: \textit{schema.sql}, que trata de criar/reiniciar as tabelas e definir as restrições de integridade, e \textit{populate.sql}, que insere um pequeno conjunto de dados de teste na Base de Dados:
    \begin{verbatim}
        $ psql -d translateRight
        translateRight=# \i schema.sql
        translateRight=# \i populate.sql
    \end{verbatim}


    \vspace{2mm}
    Apresenta-se de seguida os comandos SQL presentes no ficheiro \textit{schema.sql}:

    \small
    \begin{verbatim}
        create table local_publico (
            latitude      numeric(8, 6) not null,
            longitude     numeric(9, 6) not null,
            nome          varchar(255) not null,
            constraint pk_local_publico primary key(latitude, longitude),
            constraint latitude_check check (-90 <= latitude and latitude <= 90),
            constraint longitude_check check (-180 <= longitude and longitude <= 180)
        );

        create table item (
            id             serial,
            descricao      varchar(255) not null,
            localizacao    varchar(255) not null,
            latitude       numeric(8, 6) not null,
            longitude      numeric(9, 6) not null,
            constraint fk_item_local_publico foreign key(latitude, longitude)
                    references local_publico(latitude, longitude) on delete cascade,
            constraint pk_item primary key(id)
        );

        create table anomalia (
            id             serial,
            zona           box not null,
            imagem         bytea not null,
            lingua         varchar(255) not null,
            ts             timestamp not null,
            descricao      varchar(255) not null,
            tem_anomalia_redacao boolean not null,
            constraint pk_anomalia primary key(id)
        );

        create table anomalia_traducao (
            id             integer not null,
            zona2          box not null,
            lingua2        varchar(255) not null,
            constraint pk_anomalia_traducao primary key(id),
            constraint fk_anomalia_traducao_anomalia foreign key(id)
                        references anomalia(id) on delete cascade
        );

        create table duplicado (
            item1          integer not null,
            item2          integer not null,
            constraint pk_duplicado primary key(item1, item2),
            constraint fk_duplicado_item foreign key(item1)
                        references item(id) on delete cascade,
            constraint fk_duplicado_item2 foreign key(item2)
                        references item(id) on delete cascade,
            check(item1 < item2)
        );

        create table utilizador (
            email          varchar(255) not null,
            password       varchar(255) not null,
            constraint pk_utilizador primary key(email)
        );

        create table utilizador_qualificado (
            email           varchar(255) not null,
            constraint pk_utilizador_qualificado primary key(email),
            constraint fk_utilizador_qualificado_utilizador foreign key(email)
                        references utilizador(email)
        );

        create table utilizador_regular (
            email           varchar(255) not null,
            constraint pk_utilizador_regular primary key(email),
            constraint fk_utilizador_regular_utilizador foreign key(email)
                        references utilizador(email)
        );

        create table incidencia (
            anomalia_id        integer not null,
            item_id            integer not null,
            email              varchar(255) not null,
            constraint pk_incidencia primary key(anomalia_id),
            constraint fk_incidencia_anomalia foreign key(anomalia_id)
                        references anomalia(id) on delete cascade,
            constraint fk_incidencia_item foreign key(item_id)
                        references item(id) on delete cascade,
            constraint fk_incidencia_utilizador foreign key(email)
                        references utilizador(email)
        );

        create table proposta_de_correcao (
            email              varchar(255) not null,
            nro                integer not null,
            data_hora          timestamp not null,
            texto              text not null,
            constraint pk_proposta_de_correcao primary key(email, nro),
            constraint fk_proposta_email foreign key(email)
                        references utilizador_qualificado(email)
        );

        create table correcao (
            email              varchar(255) not null,
            nro                integer not null,
            anomalia_id        integer not null,
            constraint pk_correcao primary key(email, nro, anomalia_id),
            constraint fk_correcao_proposta foreign key(email, nro)
                        references proposta_de_correcao(email, nro) on delete cascade,
            constraint fk_correcao_incidencia foreign key(anomalia_id)
                        references incidencia(anomalia_id) on delete cascade
        );
    \end{verbatim}

    \Large
    \textbf{Consultas SQL:}

    \normalsize
    \vspace{2mm}

\begin{verbatim}
        -- Query 1
        WITH local_anomalia_count(latitude, longitude, nome, anomalia_count)
        AS (SELECT L.latitude, L.longitude, L.nome, COUNT(*)
            FROM (local_publico NATURAL JOIN item) AS L, incidencia AS I
            WHERE L.id = I.item_id
            GROUP BY (latitude, longitude))
        SELECT latitude, longitude, nome
        FROM local_anomalia_count
        WHERE anomalia_count = (SELECT MAX(anomalia_count) FROM local_anomalia_count);


        -- Query 2
        WITH utilizador_regular_tmp(email, anomalia_count)
             AS (SELECT I.email, COUNT(A.id)
                 FROM (utilizador_regular NATURAL JOIN incidencia) AS I, anomalia A
                 WHERE I.anomalia_id = A.id
                       AND A.tem_anomalia_redacao = false
                       AND TIMESTAMP '2019-01-01' <= A.ts
                       AND A.ts < TIMESTAMP '2019-07-01'
                 GROUP BY I.email)
        SELECT email
        FROM utilizador_regular_tmp
        WHERE anomalia_count = (SELECT MAX(anomalia_count) FROM utilizador_regular_tmp);


        -- Query 3
        WITH norte_rio_maior AS (SELECT * FROM local_publico
                                 WHERE latitude > 39.336775),
             utilizador_local(email, latitude, longitude)
               AS (SELECT I.email, LP.latitude, LP.longitude
                   FROM incidencia AS I, anomalia A,
                        (item NATURAL JOIN local_publico) AS LP
                   WHERE I.item_id = LP.id
                         AND I.anomalia_id = A.id
                         AND extract(year FROM A.ts) = 2019)
        SELECT distinct email
        FROM utilizador_local U1
        WHERE NOT EXISTS (SELECT latitude, longitude FROM norte_rio_maior
                          EXCEPT
                          SELECT latitude, longitude FROM utilizador_local U2
                          WHERE U1.email = U2.email);


        -- Query 4
        WITH incidencia_qual_sul(email, anomalia_id)
               AS (SELECT I.email, I.anomalia_id
                   FROM (utilizador_qualificado NATURAL JOIN incidencia) AS I,
                        (item NATURAL JOIN local_publico) AS LP, anomalia A
                   WHERE I.item_id = LP.id
                         AND I.anomalia_id = A.id
                         AND LP.latitude < 39.336775
                         AND extract(year FROM A.ts) = extract(year FROM current_date))
        SELECT distinct U1.email
        FROM incidencia_qual_sul U1
        WHERE EXISTS (SELECT U2.anomalia_id
                      FROM incidencia_qual_sul U2
                      WHERE U2.email = U1.email
                      EXCEPT
                      SELECT C.anomalia_id
                      FROM (proposta_de_correcao NATURAL JOIN correcao) AS C
                      WHERE C.email = U1.email);
    \end{verbatim}
    % \vspace*{10mm}
    \newpage
    \Large
    \textbf{Arquitetura da aplicação PHP:}

    \normalsize
    \vspace{2mm}

    \hspace*{1em}
    A página inicial da aplicação permite ao utilizador efetuar qualquer uma das ações especificadas no enunciado, através de diversos links para outras páginas \textit{.php} ou \textit{.html}. Cada uma destas páginas está dedicada a uma ação específica, coerente com o seu nome. \\

    \hspace*{1em} Todas as páginas seguem a seguinte estrutura:
    \\

    \hspace*{1em}Inicialmente é estabelecida a ligação à base de dados, usando a função \textit{connect\_db}, definida no ficheiro \textit{db.php}. Este ficheiro usa variáveis de ambiente previamente definidas no ambiente anfitrião para se autenticar na base de dados.
    \\

    \hspace*{1em} De seguida procede-se à preparação da instrução SQL a executar para efetuar a ação desejada, usando o comando \textit{\$db->prepare(\$sql))} (este comando é importante para se proteger contra ataques de SQL injection). Como cada página é dedicada a uma ação única, este query é também único para cada ação.
    Em cada página executa-se ainda um outro query SQL: este disponibiliza ao utilizador informação importante na especificação da ação que se pretende executar. A aplicação mostra os items existentes quando o utilizador pretender remover um, por exemplo.
    \\

    \hspace*{1em} Nesta fase, aguarda-se o input do utilizador, fornecido por formulários HTML. Estes forms, quando submetidos geram um POST request para uma página \textit{.php} que trata destes dados. A implementação presente usa a mesma página para receção e tratamento de dados. No tratamento de dados dá-se uma sanitização do input como medida de segurança adicional.
    \\

    \hspace*{1em} Finalmente procede-se à execução da ação, através de instruções SQL. Todas as ações que alteram o estado da base de dados são realizadas dentro de uma transação, para garantir a integridade da mesma. Depois da execução da ação, é apresentada ao utilizador uma mensagem de feedback do resultado da mesma.
    \\

    % Relacao entre as varias paginas, hierarquicamente


    % A aplicação inicia no ficheiro \textit{index.html}, onde se encontram todas as opções possíveis a realizar com a base de dados. Ao clicar em qualquer um dos links,
    %é redirecionado para uma página php que permite executar a ação pretendida. Por exemplo, se o objetivo for eliminar um item, do ficheiro \textit{index.hmtl} é redirecionado para
    %o ficheiro \textit{itemrem.php} onde estão listados todos os items da base de dados e pode escolher o item a eliminar ao carregar no botão correspondente. Todas as funcionalidades
    %estão implementadas em ficheiros diferentes, não havendo um "ficheiro único" que realize todas as ações possíveis.\\

    %\hspace*{1em} A única funcionalidade que não redireciona para um ficheiro php é a funcionalidade de listar anomalias a (dX, dY) graus de (latitude, longitude), onde se é redirecionado para um ficheiro html (\textit{anomalialatform.html})
   % para se escrever os parâmetros desejados. Depois de preencher o formulário, é redirecionado para o ficheiro %\textit{anomaliathreemonth.php}. \\

    %\hspace*{1em} ATENCÃO: para se ligar à base de dados, os ficheiros php usam as variáveis de ambiente POSTGRES\_USER e POSTGRES\_PASS, que devem ser definidas no host da base de dados. \\

    %\hspace*{1em} Qualquer página da aplicação, à exceção do \textit{index.html}, possui um link para se retroceder para a página anterior.\\

    %\hspace*{1em} Os ficheiros php desta aplicação seguem a seguinte estrutura:
    %\begin{enumerate}
     %   \item Ligação à base de dados (usando a função definida no ficheiro \textit{db.php})
      %  \item Apresentação de tabelas relevantes à execução da ação pretendida (por exemplo apresentar a lista de itens quando se quer registar itens duplicados)
      %  \item Leitura do input do utilizador, seja por meio do preenchimento de um form (ao inserir anomalias, por exemplo) ou de selecionar uma linha da tabela relevante (para eliminar locais, por exemplo)
       % \item Validação e verificação dos campos introduzidos;
    %    \item Criação de uma query SQL a executar, seguido da sua "preparação" (\textit{\$db->prepare(\$sql))})
    %    \item Execução do query e apresentação da tabela atualizada, ou de uma mensagem de confirmação

    %\end{enumerate}

    %\hspace*{1em} Todas as ações que implicam uma mudança no estado da base de dados são realizadas a partir de transações, para garantir a atomicidade das mesmas. \\

\end{document}

